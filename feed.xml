<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://nisheshawale.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://nisheshawale.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-07-15T01:51:40-05:00</updated><id>https://nisheshawale.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">The Fuel for Artificial Intelligence: Data</title><link href="https://nisheshawale.github.io/blog/2018/the-fuel-for-artificial-intelligence-data/" rel="alternate" type="text/html" title="The Fuel for Artificial Intelligence: Data"/><published>2018-12-09T09:28:28-06:00</published><updated>2018-12-09T09:28:28-06:00</updated><id>https://nisheshawale.github.io/blog/2018/the-fuel-for-artificial-intelligence-data</id><content type="html" xml:base="https://nisheshawale.github.io/blog/2018/the-fuel-for-artificial-intelligence-data/"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">Queue</title><link href="https://nisheshawale.github.io/blog/2018/queue/" rel="alternate" type="text/html" title="Queue"/><published>2018-12-05T09:09:00-06:00</published><updated>2018-12-05T09:09:00-06:00</updated><id>https://nisheshawale.github.io/blog/2018/queue</id><content type="html" xml:base="https://nisheshawale.github.io/blog/2018/queue/"><![CDATA[<p>Previously, we have seen how a stack works. In this blog, I want to give you some insights on another elementary data structure, queue. Queue works on <strong>First-In-First-Out (FIFO)</strong> principle. Queue can be modeled in real life by a line of customers waiting to pay the bill. The new customers are added at the end of the queue and the customer at the front of the queue comes out after paying the bill. Similar to the push and pop operation of stack, queue has enqueue and dequeue operation. Enqueue adds the element to the end of the queue while dequeue removes the first element from the queue.</p> <figure> <img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhNNx5L15_14AE-i_vm8MKt_0hJBhx6iA5suMZvjK0ly34uCz3S0IP5LFNc_EFDJZWq_ug9_9N2yVMsYZLyw4Ocht7CDozOXDbtLfJz1ufG_s8sOE9h3NsRbIy2ySBjRSePCfrL4EGmN0nF2fkCATuoOgijWVY93xbOkb21L9YfI3cuAP4m-3X09WMr/s860/queue.png" alt="Loading" width="100%" height="auto" align="center"/> <figcaption>(a) Queue Q has 5 elements at location Q[7...11]. (b) Queue Q after ENQUEUE(Q, 17), ENQUEUE(Q, 3), and ENQUEUE(Q, 5). (c) Queue Q after DEQUEUE(Q). [Source: <a href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844">Introduction to Algorithms]</a></figcaption> </figure> <p>Here, we implement a queue using an array Q [1…n]. Queue has its attribute, Q.head which points to the head of the queue. Also, Q.tail points to the next location at which the new element will be inserted. When Q.head == Q.tail then, we can infer that the queue is empty. The queue is full if Q.head = Q.tail + 1. Similar to stack, the queue underflows if we try to dequeue an empty queue and the queue overflows if we try to enqueue an element in the full queue.</p> <p>Pseudocode: ENQUEUE(Q, x)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q[Q.tail] = x
if Q.tail == Q.length   //queue is made circular when all array space has been used
    Q.tail = 1
 else
    Q.tail = Q.tail + 1
</code></pre></div></div> <p>DEQUEUE(Q)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = Q[Q.head]
if Q.head == Q.length
    Q.head = 1      //when all the elements has been dequeue then Q.head points to first location
else
    Q.head = Q.head + 1
return x
</code></pre></div></div> <p>We can see that the both operations above are constant time operation i.e. the running time of both enqueue and dequeue operation is bounded by θ(1). Queue has an important application in breadth first search (BFS) where it is used to store the nodes which have been visited and remove the nodes which have been expanded. The main disadvantage of implementing queue using an array is that the array space should be defined for the maximum number of elements. If this space is not sufficient, then it is difficult to add more while if too much space is allocated then, there will be wastage of space.</p> <p>Originally Posted on:<br/> <a href="https://nisheshawale.blogspot.com/2018/12/queue.html">My blog series</a></p> <p>Reference:<br/> <a href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844">Introduction to Algorithms by CLRS</a></p>]]></content><author><name></name></author><category term="computer-science"/><category term="dsa"/><category term="code"/><summary type="html"><![CDATA[Explanation of queue data structure]]></summary></entry><entry><title type="html">Stack</title><link href="https://nisheshawale.github.io/blog/2018/stack/" rel="alternate" type="text/html" title="Stack"/><published>2018-11-23T09:09:00-06:00</published><updated>2018-11-23T09:09:00-06:00</updated><id>https://nisheshawale.github.io/blog/2018/stack</id><content type="html" xml:base="https://nisheshawale.github.io/blog/2018/stack/"><![CDATA[<p>Stack is one of the elementary data structure in which elements are added and deleted using <strong>Last-In-First-Out (LIFO)</strong> principle. To understand LIFO principle, let us consider a teacher is checking the examination paper. After checking each paper, he/she keeps the papers by his/her side such that the first paper checked, remained at the bottom and the last paper checked, remained at the top. So, the paper is inserted at the top of the pile of paper. While distributing the examination paper, the first paper to be removed, is the one which was on the top of the pile. This is known as LIFO principle.</p> <figure> <img alt="Loading" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhNfplLoCyFMyHxNAGbbt__q4LX64OixGAIzvUDs7hii2s96XCzwaW-fGbfSfdDCwAsWc3O1bS3P8qeCQX0cin5_D_1fMH11ER8-6BkQ7ZUKieXnfhOOQUq1b7vhT_xKW8tWFaEsUCsXGCoh_nlVvTXeukOkPp_6nQXSv1BIOwgPx8ivSWB3p2Yfev1/s1275/stack.png" width="100%" height="auto" align="center"/> <figcaption>(a) Stack S has 4 elements and its top element is 9. (b) Stack S after STACK_PUSH(S, 17) and STACK_PUSH(S, 3). (c) Stack S after STACK_POP(S). [Source: <a href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844">Introduction to Algorithms]</a></figcaption> </figure> <p>Here, we will see the implementation of stack using an array. Let, S[1…n] be the array. The stack has an attribute, S.top which gives index of the most recently added element. The stack is empty if S.top = 0. The insert and delete operation in the stack has special names, <strong>push</strong> and <strong>pop</strong> respectively. If we try to push an element in the stack containing n elements, an error occurs which is known as stack overflow. Similarly, if we try to pop an empty stack, stack underflow occurs. Now, let’s see the operations in the stack.</p> <p>STACK_EMPTY(S)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if S.top == 0
    return True
else
    return False
</code></pre></div></div> <p>STACK_PUSH(S, x)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if S.top == n
    Error “Stack Overflow”
else
    S.top = S.top + 1
    S[S.top] = x
</code></pre></div></div> <p>STACK_POP(S)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if STACK_EMPTY(S)
    Error “Stack Underflow”
else
    S.top = S.top – 1
    return S[S.top + 1]
</code></pre></div></div> <p>If we analyze the running time of each operation, we can see that each of the operations take O(1) time. O(1) time simply means that the time required is constant and it does not change even if the size of the array is made large. Every modern programming languages have the library facility to implement stack. For example, in C++, you can use Standard Template Library (STL) to implement stack. Now, let’s consider a simple operation in which we can use stack. Suppose we have to take the input from the user and print it in reverse form. Then, we can use stack to store the input then, pop the value from the stack. Algorithm to print the input from the user in reverse form</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while (input != newline)
    Store input in variable x
    STACK_PUSH (S, x)
while(!STACK_EMPTY)  
    x = STACK_POP (S)             //pops value from the stack and store it in variable x
    Output x
</code></pre></div></div> <p>In the above algorithm, if the input is in the sequence 1 2 3 4 5 then, the output will be 5 4 3 2 1.</p> <p>Originally Posted on:<br/> <a href="https://nisheshawale.blogspot.com/2018/11/stack.html">My blog series</a></p> <p>Reference book:<br/> <a href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844">Introduction to Algorithms by CLRS</a></p>]]></content><author><name></name></author><category term="computer-science"/><category term="dsa"/><category term="code"/><summary type="html"><![CDATA[Explanation of stack data structure]]></summary></entry><entry><title type="html">Binary Search</title><link href="https://nisheshawale.github.io/blog/2018/binary-search/" rel="alternate" type="text/html" title="Binary Search"/><published>2018-11-17T09:09:00-06:00</published><updated>2018-11-17T09:09:00-06:00</updated><id>https://nisheshawale.github.io/blog/2018/binary-search</id><content type="html" xml:base="https://nisheshawale.github.io/blog/2018/binary-search/"><![CDATA[<p>Binary search is used to locate an element in an array efficiently than the linear search. To use a binary search, the array must be sorted in non-decreasing order. If A[1…n] is the sorted array, then the binary search returns an index i at which the element(say x) is found. If the element is not in the array then, it returns a possible index where the element might be inserted. Here, we wish to find the index i such that 1 &lt; i &lt; n + 1 and A[i - 1] &lt; x &lt; A[i].</p> <p>At first, let’s see how do we locate an element in an array using linear or sequential approach.</p> <p>LINEAR-SEARCH (A[1…n], x)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i = 1 to n
    if A[i] &gt; x
        return i
return n + 1
</code></pre></div></div> <p>From the above algorithm, we can see clearly that the algorithm takes the time in θ(n) in the worst case where n is the number of elements. Now, let’s see how binary search algorithm will improve this running time. Basically, a binary search algorithm works like this. First, we compare the element x with the middle element of the array. As the array is sorted, if x is greater than the middle element of the array, then we do not have to search x in the left portion of the array. Otherwise, we search for x in the left portion of the array and do not have to search in the right portion of the array. The figure below will illustrate this.</p> <p>Suppose we are searching for the number 9 in the sorted array:</p> <figure align="center"> <img alt="Loading" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi92JZtZ_KRTtp3CnRxBb7RkK1pntDRPRXXBCJhYjmW9FtvABUMlcNLJb2f1YhxSYrn20PsaMW3drAjOsnquiYJ-6l7FJ3TKBA6x4EMcNXbzJoyzNombHjdOkl9UHU9GKKO8R00vNH4vcwtLzYGJY5-mgY1RpiTB1FQRhdBST-JJusi7UvA37c2SYSr/s320/binary_search.png"/> <figcaption align="center">Binary search for x = 12 in T[1...11] [Source: <a href="https://www.amazon.com/Fundamentals-Algorithmics-Gilles-Brassard/dp/0133350681">Fundamental of Algorithmics</a>]</figcaption> </figure> <p>In the pseudocode below, we first check whether x lies within the range A[1] to A[n]. If it does not, we will return n + 1 and avoid the unnecessary recursive calls.</p> <p>BINARY-SEARCH(A[1…n], x)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if n = 0 or x &gt; A[n]
    return n + 1
else
    return BINARY-RECURSIVE(A[1…n], x)
</code></pre></div></div> <p>BINARY-RECURSIVE(A[i…j], x)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if i == j
    return i
k = (i + j) / 2
if x &lt; A[k]
    return BINARY-RECURSIVE(A[1…k], x)
else
    return BINARY-RECURSIVE(A[k + 1 … n], x)
</code></pre></div></div> <p><strong>Analysis:</strong><br/> Let, T(n) be the time required for a call on BINARY-RECURSIVE(A[i…j], x) where n = j – i + 1 is the number of elements. The time required for BINARY-SEARCH(A[1..n], x) is also T(n) with a small additive constant for conditional checking. For the recursive call we can use T(n) = T(n/2) + g(n) when n is even and g(n) = θ(1) = θ(n<sup>0</sup>) = θ(n<sup>log<sub>2</sub>1</sup>) because the algorithm takes a constant amount of time besides recursive calls. Even when n is odd, master theorem can be used and by using master theorem, T(n) = θ(n<sup>log<sub>2</sub>1</sup> log n) = θ(log n). So, binary search has logarithmic time complexity.</p> <p>I think it is worth mentioning that the above algorithm can be implemented iteratively rather than recursively. The running time will be same in both cases. The only difference is that recursion needs some additional spaces because of function calls.</p> <p>Originally Posted On:<br/> <a href="https://nisheshawale.blogspot.com/2018/11/binary-search.html">My blog series</a></p> <p>Reference:<br/> <a href="https://www.amazon.com/Fundamentals-Algorithmics-Gilles-Brassard/dp/0133350681">Fundamentals of Algorithmics</a></p>]]></content><author><name></name></author><category term="computer-science"/><category term="dsa"/><category term="code"/><summary type="html"><![CDATA[Explanation of binary search algorithm]]></summary></entry></feed>